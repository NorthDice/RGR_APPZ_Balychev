# Розрахунково графічна робота 
Розрахунково графічна робота на тему «Шаблони проектування»
В даній розрахунково графічній роботі буде розглянуто наступні шаблони проектування, а саме: Object pool, Bridge, Null Object, Reactor.
## Object pool
Object pool — твірний шаблон проєктування, набір ініціалізованих і готових до використання об'єктів. Коли системі потрібно об'єкт, він не створюється, а береться з пулу. Коли об'єкт більше не потрібен, він не знищується, а повертається в пул.

### Призначення

Пул об'єктів призначений для зберігання готових до використання об'єктів. Коли система потребує новий об'єкт, він запрошується з пула, нехтуючи процесом породження. А після використання повертається назад в пул замість знищення.

### Умови використання

Шаблон використовується для підвищення продуктивності, якщо:

•	об'єкти часто створюються і знищуються;
•	система має обмежену кількість типів об'єктів, що зберігаються в Пулі.
•	створення чи знищення об'єкта є дуже затратною операцією.

### Особливості використання

Пул нічого не знає про реалізацію об'єктів, які зберігаються. Тому вважається, що повернений об'єкт знаходиться в невизначеному стані. Для подальшого використання його необхідно перевести в початковий стан (скидання). Наявність об'єктів в невизначеному стані перетворює Пул в «об'єктну клоаку» (object cesspool). Повторне використання може стати причиною витоку конфіденційної інформації. Тому обов'язково необхідно зчищати поля з секретними даними при скиданні, а самі дані — знищувати. Можлива ситуація, коли в Пулі не залишиться вільних об'єктів. В такому випадку, реакція на запит може бути наступною:

•	збільшення розміру пула;
•	відмова у видачі об'єкта;
•	становлення в чергу і очікування звільнення об'єкта.

### Статична модель (діаграма класів або модулів) ObjectPool

![Статична модель Object Pool](https://github.com/NorthDice/RGR_APPZ_Balychev/blob/main/ObjectPoolClassDiagram.jpg)

### Динамічна модель (діаграма взаємодії або стану) Object Pool
    
![Динамічна модель Object Pool](https://github.com/NorthDice/RGR_APPZ_Balychev/blob/main/ObjtctPoolSequenseDiagram.jpg)

## Bridge

Bridge —  шаблон проєктування, призначений для того, щоб відділити абстракцію від її конкретної імплементації таким чином, щоб вони могли бути змінені незалежно один від одного. Належить до класу структурних шаблонів.

### Призначення

Відокремити абстракцію від її реалізації таким чином, щоб перше та друге можна було змінювати незалежно одне від одного.
Терміни абстракція та реалізацію не мають нічого спільного з абстрактним класом чи інтерфейсом мови програмування. Абстракція — це уявний рівень керування чим-небудь, що не виконує роботу самостійно, а делегує її рівню реалізації.

### Умови використання

Слід використовувати шаблон Міст у випадках, коли:

•	треба запобігти постійній прив'язці абстракції до реалізації. Так, наприклад, буває коли реалізацію необхідно обрати під час виконання програми;
•	як абстракції, так і реалізації повинні розширюватись новими підкласами. У цьому разі шаблон Міст дозволяє комбінувати різні абстракції та реалізації та змінювати їх незалежно одне від одного;
•	зміни у реалізації не повинні впливати на клієнтів, тобто клієнтський код не повинен перекомпілюватись;
•	треба повністю сховати від клієнтів реалізацію абстракції;
•	треба розподілити одну реалізацію поміж кількох об'єктів (можливо застосовуючи підрахунок посилань), і при цьому приховати це від клієнта.

### Статична модель (діаграма класів або модулів) Bridge

![Статична модель Bridge](https://github.com/NorthDice/RGR_APPZ_Balychev/blob/main/BridgeClassDiagram.jpg)

### Динамічна модель (діаграма взаємодії або стану) Bridge

![Динамічна модель Bridge](https://github.com/NorthDice/RGR_APPZ_Balychev/blob/main/BridgeSequenceDiagram.jpg)

## Null object

В об'єктно-орієнтованому програмуванні, Null Object або нульовий об'єкт — це об'єкт з визначеною нейтральною поведінкою. Шаблон проєктування Null Object описує використання цих об'єктів та їх поведінки або відсутності таких. 

### Призначення

Замість використання null-посилання для відображення відсутності об'єкту треба використовувати спеціальний об'єкт, який реалізує потрібні інтерфейси, але не має поведінки, тобто має пусті методи. Перевагою цього підходу є те, що реалізація нульового об'єкту завжди передбачувана: вона нічого не робить, а тому не має таких побічних ефектів, які має null-посилання.

Наприклад, функція повинна прочитати список файлів в директорії та виконати якісь дії з кожним. В випадку, якщо директорія порожня, можна повернути null або згенерувати виняток. Таким чином, код, що очікує список файлів повинен перевіряти, чи дійсно він отримав список, а це в свою чергу ускладнює структуру програми.

Якщо повертати нульовий об'єкт (наприклад, порожній список), то зникає необхідність перевірок. Викликаючий код може ітерувати список файлів, не зважаючи на можливі помилки і не виконувати ніяких дій при цьому.
Хоча, залишається можливим робити дещо змінену перевірку: «чи дорівнює результат нульовому об'єкту?», та діяти далі за логікою програми.
Також, цей шаблон може використовуватися як заглушка при тестуванні.

### Статична модель (діаграма класів або модулів) Null Object

![Статична модель Null Object](https://github.com/NorthDice/RGR_APPZ_Balychev/blob/main/NullObjectClassDiagram.jpg)

### Динамічна модель (діаграма взаємодії або стану) Null Object

![Динамічна модель Null Object](https://github.com/NorthDice/RGR_APPZ_Balychev/blob/main/ObjtctPoolSequenseDiagram.jpg)

## Reactor

Шаблон проектування програмного забезпечення реактор – стратегія обробки подій , яка може одночасно реагувати на безліч потенційних запитів на обслуговування. Ключовим компонентом шаблону є цикл подій , що працює в одному потоці або процесі , який демультиплексує вхідні запити та відправляє їх потрібного обробника запитів. 
Покладаючись на механізми, засновані на подіях, а не на блокуючий введення-виведення або багатопоточність, реактор може обробляти безліч конкурентних запитів, що межують з введенням-виведенням, з мінімальною затримкою. Реактор також дозволяє легко змінювати або розширювати окремі процедури обробки запитів, хоча цей шаблон має деякі недоліки та обмеження. 

### Призначення

Шаблон реактора може стати гарною відправною точкою для вирішення будь-якої паралельної проблеми обробки подій. Цей шаблон не обмежується мережевими сокетами; апаратне введення-виведення, доступ до файлової системи або бази даних , між-процесна взаємодія і навіть абстрактні системи передачі повідомлень - все це можливі варіанти використання.

Однак шаблон реактора має обмеження, головним з яких є використання зворотних викликів, які ускладнюють аналіз та налагодження програми — проблема, характерна для проектів з інвертованим управлінням . Простіші підходи: «потік на з'єднання» і повністю ітеративний підхід, дозволяють уникнути цього і можуть бути прийнятними рішеннями, якщо не потрібна масштабованість або висока пропускна здатність.

Однопоточність може стати недоліком у випадках, що потребують максимальної пропускної здатності або коли запити потребують значної обробки. Подолати ці обмеження можуть різні багатопотокові конструкції. І фактично деякі з них досі використовують шаблон реактора як підкомпонент для обробки подій і введення-виведення. 

### Статична модель (діаграма класів або модулів) Reactor

![Статична модель Reactor](https://github.com/NorthDice/RGR_APPZ_Balychev/blob/main/ReactorClassDiagram.jpg)

### Динамічна модель (діаграма взаємодії або стану) Reactor

![Динамічна модель Reactor](https://github.com/NorthDice/RGR_APPZ_Balychev/blob/main/ReactorSequanceDiagram.jpg)






